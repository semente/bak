#!/bin/bash
## bak --- simple, efficient, and encrypted backups
#
# Copyright (C) 2016 Guilherme Gondim <https://semente.io>
#
# Website: https://github.com/semente/bak
# Keywords: backup, cryptography, commandline
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# exit on error
set -e

NAME=`basename $0`
VERSION="0.2-pre"
WEBSITE="https://github.com/semente/bak"
AUTHOR="Guilherme Gondim <https://semente.io>"

FIND_ARGS=()
GPG_ARGS=(--quiet --yes --encrypt --sign)
LOGGER_ARGS=(--tag="$NAME")
RSYNC_ARGS=(--chmod=0600)
TAR_ARGS=(--exclude-backups --exclude-caches --exclude-tag=.nobackup)

VERBOSE=0
DESTS=()

# incremental backups are based on last modification time of this file
LASTFILE=".bak"


function print_version() {
    echo "$NAME version $VERSION"
    echo "Copyright (C) 2016 by $AUTHOR"
    echo
    echo "$NAME comes with ABSOLUTELY NO WARRANTY.  This is free software, and"
    echo "you are welcome to redistribute it under certain conditions.  See the"
    echo "GNU General Public Licence version 3 for details."
}

function print_usage() {
    echo "Usage: $NAME [OPTION]... [[USER@]HOST:]DEST..."
    echo "Try \`$0 -h' for more information."
}

function print_help() {
    print_version
    echo
    print_usage | head -1
    echo "Creates a backup of the current directory to one or more DEST in local"
    echo "or remote hosts."
    echo
    echo "If there is a previous backup (i.e. there is a \`.bak' in the current"
    echo "directory) the next backup will ignore any files older than the"
    echo "\"lastfile\" \`.bak'. You must use the option \`-f' to force a full"
    echo "backup, if desired."
    echo
    echo " Examples:"
    echo
    echo "  cd \$HOME && $NAME /media/usb/backups"
    echo "  cd /some/dir/to/backup && $NAME -f /dest/one user@remote:/dest/two"
    echo
    echo " Options:"
    echo
    echo "  -f                      force a full backup (i.e. ignore lastfile .bak)"
    echo "  -r RECIPIENT-KEY        encrypt for user id RECIPIENT-KEY"
    echo "  -k SIGN-KEY             use SIGN-KEY as the key to sign with"
    echo "  -s SIZE                 don't backup any file larger than SIZE kbytes"
    echo "  -i IDENTITY-FILE        selects a identity for public key authentication over SSH"
    echo "  -u                      non interactive-commonly used for unattended operations"
    echo "  -v                      verbose (i.e. give more information during processing)"
    echo "  -d                      print commands as they are executed (for debug)"
    echo "  -n                      read commands but do not execute them (dry run)"
    echo "  -V                      print version number"
    echo "  -h                      show this help text"
    echo
    echo "See <$WEBSITE> for more information or bug reports."
}

function log() {
    local msg="$*"
    if [ -x "`which logger`" ]; then
        logger "${LOGGER_ARGS[@]}" $msg
    else
        echo "$NAME: $msg" >&2
    fi
}

function warn() {
    local msg="$*"
    if [ $VERBOSE = 1 ]; then
        # on verbose mode, `log' will also print its output to stderr
        log "$msg"
    else
        echo "$NAME: $msg" >&2
        log "$msg"
    fi
}

function fail() {
    local msg="$*"
    [ -n "$msg" ] && warn "$msg"
    print_usage
    exit 2
}

function parse_commandline() {
    local option rcpt_key sign_key size identity_file
    while getopts fuvdnVhr:k:s:i: option; do
        case $option in
            f)
                rm -f "$LASTFILE"
                ;;
            u)
                GPG_ARGS+=(--batch --no-tty)
                ;;
            v)                  # verbose
                VERBOSE=1
                GPG_ARGS+=(--verbose)
                RSYNC_ARGS+=(--verbose)
                TAR_ARGS+=(--verbose)
                LOGGER_ARGS+=(--stderr)
                ;;
            d)                  # debug
                set -x
                ;;
            n)                  # dry run
                fail "dry run \(-n\) not implemented yet"
                #set -vn
                ;;
            V)                  # version
                print_version && exit
                ;;
            h)                  # help
                print_help && exit
                ;;
            r)
                rcpt_key="$OPTARG"
                GPG_ARGS+=(--recipient="$rcpt_key")
                ;;
            k)
                sign_key="$OPTARG"
                GPG_ARGS+=(--local-user="$sign_key")
                ;;
            s)
                size="$OPTARG"
                FIND_ARGS+=("-size -${size}k")
                ;;
            i)
                identity_file="$OPTARG"
                RSYNC_ARGS+=(--rsh="ssh -i $identity_file")
                ;;
            *)                  # invalid option
                fail
        esac
    done
    shift `expr $OPTIND - 1`

    local argnum=$#
    if [ $argnum -lt 1 ]; then
        fail "missing destination operand"
    fi

    local dest
    for dest in "$@"; do
        # check if `$dest' have a form `[[USER@]HOST:]DEST'
        local user_re="[a-z0-9A-Z][-a-z0-9A-Z_]*"
        local host_re="[-a-z0-9A-Z_.]+"
        local dest_re="[-a-z0-9A-Z_/.~]+"
        set +e
        echo $dest | grep -E "^${dest_re}\$" > /dev/null
        if [ $? -gt 0 ]; then
            echo $dest | grep -E \
                "^((${user_re}@)?${host_re}:)?${dest_re}\$" > /dev/null
            if [ $? -gt 0 ]; then
                fail "invalid destination $dest"
            fi
        fi
        set -e

        # excludes directory destination when performing a local backup
        TAR_ARGS+=(--exclude="$dest")

        DESTS+=("$dest")
    done
}

function backup() {
    local baktype
    [ -f "$LASTFILE" ] && baktype=incr || baktype=full

    # Use `$LASTFILE' as reference for the incremental backup
    [ $baktype = incr ] && FIND_ARGS+=("-newer $LASTFILE")

    # Tar excludes patterns listed in .bakignore if found in the current directory
    [ -f .bakignore ] && TAR_ARGS+=(--exclude-from=".bakignore")

    # determine where the backup file is temporarily stored before sent to DEST
    local bakfile="`mktemp --suffix=-bak -d`/`date --utc --iso-8601=s`.${baktype}.tar.gz.gpg"
    trap "rm -f $bakfile && rmdir `dirname $bakfile`" EXIT

    # Make a list of files to backup that size is less than `$SIZE'
    # (if set) and newer than `$LASTFILE' (if present); then create a
    # PGP encrypted tar.gz archive.
    find -type f "${FIND_ARGS[@]}" -print0 |
        tar "${TAR_ARGS[@]}" \
            --exclude="$LASTFILE" \
            --null \
            --files-from - \
            -cz |
        gpg "${GPG_ARGS[@]}" \
            --output "$bakfile"

    # send `$bakfile' to DEST using rsync
    set +e
    local dest
    for dest in "${DESTS[@]}"; do
        rsync "${RSYNC_ARGS[@]}" "$bakfile" "${dest}/"
        if [ $? -gt 0 ]; then
            FAILED=1
            warn "Failed to send backtup to $dest"
        else
            log "Sending backup of `pwd` to $dest succeeded"
        fi
    done
    set -e

    # update last modification time of `$LASTFILE' if backup succeeded
    #
    # XXX: When sending backups to multiple destinations, `.bak' last
    #      modification time won't be updated if rsync failed for at
    #      least one destination.
    #
    [ -z $FAILED ] && touch "$LASTFILE"

}

function main() {
    parse_commandline "$@"
    trap 'warn "An unknown error occurred while backing up `pwd`. Aborted"' EXIT
    backup
}

main "$@"
